## Setup project structure and dependencies

- Created package.json with Vite, TypeScript, and Vitest dependencies
- Created tsconfig.json with strict TypeScript settings for ES2020 bundler mode
- Created vite.config.ts with build and dev server configuration
- Restructured project:
  - index.html moved to root (Vite convention)
  - src/main.ts as the TypeScript entry point
  - src/style.css extracted from POC
  - src/types.ts with Service and Connection type definitions
  - src/data/services.ts with typed service and connection data
- Added src/data/services.test.ts with Vitest tests for data integrity
- Updated .gitignore to include dist/
- All tests passing (7 tests)
- Build produces production-ready output in dist/

## Initial implementation of network visualization using canvas element

- Created src/canvas/CanvasRenderer.ts - a modular canvas rendering class that handles:
  - Drawing AWS service nodes with category-specific gradient colors
  - Drawing connection lines between related services
  - Mouse-based pan (drag) and zoom (wheel) navigation
  - Zoom towards mouse position for intuitive zooming
  - Hit detection for clicking on service nodes
  - Hover state detection with cursor changes
  - Selection state highlighting
  - HiDPI/Retina display support via devicePixelRatio
- Updated src/main.ts to use CanvasRenderer instead of DOM-based rendering
- Updated index.html to use a canvas element instead of a div
- Simplified src/style.css by removing DOM node/connection styles (now drawn on canvas)
- Added comprehensive tests in src/canvas/CanvasRenderer.test.ts:
  - Tests for initialization and state management
  - Tests for view reset and focus on service
  - Tests for render method (context calls verification)
  - Tests for service click callbacks
  - Tests for error handling (null context)
- Added happy-dom as dev dependency for DOM testing environment
- Updated vite.config.ts with happy-dom test environment
- All tests passing (24 tests: 7 data + 17 canvas)

## Ensure canvas navigation works as expected

- Fixed drag/click conflict by tracking total drag distance and using a 5px threshold to distinguish clicks from drags
- Added touch event support for mobile devices:
  - Single-finger pan (drag to move the view)
  - Two-finger pinch-to-zoom with zoom toward pinch center
  - Tap-to-select services on touch devices
- Added keyboard navigation for accessibility:
  - Arrow keys for panning (50px per keypress)
  - +/- keys for zooming in/out
  - 0 key to reset view (center on content)
  - Escape key to deselect current service
  - Canvas is now focusable (tabindex="0")
- Added automatic view centering on content:
  - Initial view centers and scales to fit all services with padding
  - Reset view now centers on content instead of returning to (0,0)
  - New public `centerViewOnContent()` method calculates bounding box and fits view
- Updated tests in src/canvas/CanvasRenderer.test.ts:
  - Added tests for touch event listener setup
  - Added tests for keyboard event listener setup
  - Added tests for keyboard navigation (all arrow keys, zoom keys, reset, escape)
  - Added tests for centerViewOnContent behavior
  - Updated existing tests to account for auto-centered initial state
- All tests passing (36 tests: 7 data + 29 canvas)

## Add support for showing detailed descriptions of services when clicked

- Created src/ui/InfoPanel.ts - a modular info panel component that handles:
  - Displaying service details (name, category, description, details, key points)
  - Close button with proper event handling
  - XSS protection via HTML escaping for all user-provided content
  - Show/hide functionality with CSS class toggling
  - Callback support for close events
- Updated src/main.ts to use the new InfoPanel class:
  - Refactored from inline DOM manipulation to modular component
  - Integrated close callback with canvas renderer for proper state sync
- Enhanced src/style.css with close button styling:
  - Positioned absolutely in top-right corner
  - Hover effects with color transitions
  - Proper padding on h2 to avoid overlap
- Added comprehensive tests in src/ui/InfoPanel.test.ts:
  - Tests for initialization and visibility state
  - Tests for show/hide functionality
  - Tests for service content rendering (name, category, description, details, key points)
  - Tests for close button behavior and callback
  - Tests for XSS protection (HTML escaping verification)
  - Tests for service switching
- All tests passing (56 tests: 7 data + 29 canvas + 20 info panel)

## Move content to JSON files

- Created src/data/services.json containing all AWS service data:
  - 34 services with name, category, description, details, keyPoints, and x/y coordinates
  - Structured for easy editing by non-developers
- Created src/data/connections.json containing all service relationships:
  - 45 connections as [from, to] tuples
  - Maintains the same graph structure as before
- Refactored src/data/services.ts to import from JSON files:
  - Uses Vite's native JSON import support
  - Type assertions ensure proper TypeScript types (ServiceMap, Connection[])
  - Clean separation of content (JSON) from code (TypeScript)
- All existing tests continue to pass (56 tests) verifying data integrity

## Add content for additional services

- Expanded services.json from 34 to 55 AWS services (+21 new services)
- Added new "devtools" category for CI/CD services with blue gradient color
- New services added with full descriptions and key points:
  - Compute/Serverless: API Gateway, Step Functions, EKS
  - Security: Cognito, Secrets Manager, WAF, Shield, GuardDuty, Inspector
  - DevTools: CodePipeline, CodeBuild, CodeDeploy
  - Database: ElastiCache, Redshift, Athena
  - Messaging: EventBridge, Kinesis
  - Networking: NAT Gateway, Direct Connect, VPN Gateway
  - Management: X-Ray
  - Storage: Storage Gateway, Snow Family
- Expanded connections.json from 45 to 106 connections (+61 new connections)
- All services include certification-relevant key points for:
  - AWS Cloud Practitioner
  - AWS Solutions Architect Associate
  - AWS Developer Associate
- Updated src/types.ts to include new 'devtools' category
- Updated src/canvas/CanvasRenderer.ts with devtools category color
- Updated src/data/services.test.ts to validate new category
- All tests passing (56 tests)

## Add extra description for each service with Learn More button

- Updated src/types.ts with new optional fields:
  - Added Resource interface with title and url properties
  - Added extendedDescription (optional string) to Service interface
  - Added resources (optional Resource[]) to Service interface
- Updated src/data/services.json with extended content for 7 key services:
  - EC2, Lambda, S3, VPC, IAM, RDS, DynamoDB
  - Each includes detailed extendedDescription with certification-relevant information
  - Each includes 3 resource links (Documentation, Best Practices/Pricing/Features)
- Enhanced src/ui/InfoPanel.ts with Learn More functionality:
  - Added isExpanded state to track toggle state
  - Added isExtendedContentVisible() public method for testing
  - Added toggleExpanded() public method to toggle state
  - Added hasExtendedContent() private method to check for extended content
  - Updated render() to show "Learn more" / "Show less" button when extended content exists
  - Extended content section shows extendedDescription and resources when expanded
  - Resources rendered as links with target="_blank" and rel="noopener noreferrer"
  - Button has aria-expanded attribute for accessibility
  - All content properly escaped for XSS protection
- Updated src/style.css with styles for the new elements:
  - .learn-more-btn with gradient background and hover effects
  - .extended-content container with top border separator
  - .extended-description section styling
  - .resources section with styled links and external link indicator (↗)
- Added comprehensive tests in src/ui/InfoPanel.test.ts:
  - Tests for Learn More button visibility based on extended content
  - Tests for expand/collapse toggle behavior
  - Tests for aria-expanded accessibility attribute
  - Tests for extended description rendering
  - Tests for resources links rendering with correct attributes
  - Tests for showing only description or only resources
  - Tests for state reset when switching services or hiding panel
  - Tests for XSS protection in extended content
- All tests passing (73 tests: 7 data + 29 canvas + 37 info panel)

## Prepare CI/CD pipeline for deployment to AWS Lambda

- Created Lambda handler in lambda/handler.ts:
  - Serves static files from compiled Vite output in /dist directory
  - Supports all common MIME types (HTML, CSS, JS, JSON, images, fonts)
  - Binary files (PNG, JPG, WOFF, etc.) served as base64-encoded responses
  - Directory traversal attack prevention by sanitizing paths
  - SPA routing support: falls back to index.html for non-file routes
  - Smart cache headers: no-cache for HTML, immutable for static assets
  - Error handling with 404 and 500 responses
  - Compatible with AWS Lambda Function URLs and API Gateway HTTP API
- Created lambda/tsconfig.json for Lambda-specific TypeScript compilation
- Created Dockerfile for AWS Lambda container:
  - Multi-stage build: Node.js Alpine for building, AWS Lambda Node.js 20 for runtime
  - First stage: installs dependencies, builds static site with Vite, compiles Lambda handler
  - Second stage: copies built assets and handler into Lambda runtime environment
  - Handler entry point: handler.handler
- Created .github/workflows/ci.yml for continuous integration:
  - Runs on push to main/master and pull requests
  - TypeScript type checking
  - Vitest test execution
  - Application build verification
  - Docker image build verification
- Created .github/workflows/deploy.yml for continuous deployment:
  - Runs on push to main/master with manual trigger option
  - Configurable via GitHub variables: AWS_REGION, ECR_REPOSITORY, LAMBDA_FUNCTION_NAME
  - Uses GitHub secrets for AWS credentials: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY
  - Builds and pushes Docker image to Amazon ECR (tagged with git SHA and latest)
  - Updates Lambda function with new container image
  - Waits for Lambda update to complete before finishing
- Created .env.example with documentation for required environment variables
- Updated package.json with new scripts:
  - build:lambda - compiles Lambda handler
  - build:all - builds both static site and Lambda handler
  - docker:build - builds Docker image locally
  - docker:run - runs Docker container locally on port 9000
- Added @types/aws-lambda dev dependency for TypeScript type support
- Updated .gitignore to include lambda-dist/ output directory
- Added comprehensive tests in lambda/handler.test.ts:
  - Tests for serving index.html at root path
  - Tests for MIME type detection (CSS, JS, PNG, SVG)
  - Tests for directory traversal attack prevention
  - Tests for 404 handling and SPA fallback
  - Tests for binary file base64 encoding
  - Tests for cache header configuration
  - Tests for error handling (500 responses)
- All tests passing (84 tests: 7 data + 29 canvas + 37 info panel + 11 lambda handler)

## Revise and polish design

- Added missing devtools category to legend in index.html
- Introduced CSS custom properties (variables) in :root for consistent theming:
  - Color palette: --color-primary, --color-primary-light, --color-primary-dark
  - UI tokens: --color-bg-dark, --color-text, --color-text-muted
  - Spacing/effects: --border-radius, --shadow, --shadow-hover
  - Timing: --transition-fast (0.15s), --transition-normal (0.25s)
- Added glassmorphism effect to all panels with backdrop-filter: blur(12px)
- Improved info panel:
  - Smooth slide-in animation using opacity, visibility, and transform
  - Custom scrollbar styling for Webkit browsers (purple-tinted)
  - Better visual hierarchy with improved typography and spacing
  - Close button redesigned with subtle border and scale animations
  - Category badges with rounded pill design and uppercase text
  - Description/details now have distinct styles for better readability
  - Key points section with colored bullet markers
  - Extended content section with fade-in animation
- Improved controls panel:
  - Buttons use translucent background with subtle border
  - Hover states include transform and color transitions
  - Active states provide tactile feedback
- Improved legend panel:
  - Hover states on legend items for interactivity
  - Legend color swatches have subtle shadow
- Added responsive design improvements:
  - Mobile breakpoint (768px): Info panel slides up from bottom
  - Small screens (480px): Legend hidden to save space
  - Adjusted padding, font sizes, and spacing for touch devices
- Added focus-visible states for keyboard accessibility on all interactive elements
- Updated body font stack to include system fonts for cross-platform consistency
- Added devtools category color (.devtools gradient class)
- All tests continue to pass (84 tests)

## Prepare deployment documentation

- Created comprehensive DEPLOYMENT.md covering:
  - Architecture overview with diagram
  - Prerequisites and required AWS permissions (IAM policy)
  - AWS infrastructure setup instructions:
    - ECR repository creation
    - Lambda function creation with execution role
    - Function URL configuration with CORS
  - GitHub Actions configuration:
    - Required secrets (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY)
    - Optional variables (AWS_REGION, ECR_REPOSITORY, LAMBDA_FUNCTION_NAME)
  - Local development commands (dev server, tests, builds)
  - Local Docker testing with curl examples
  - Manual deployment steps (without GitHub Actions)
  - Troubleshooting section for common issues:
    - Container startup failures
    - Function URL 500 errors
    - ECR push failures
    - Deployment workflow failures
  - Estimated AWS costs (< $1/month for low-traffic)
- Updated PRD.md marking deployment documentation as complete

## Revise graph layout - non-overlapping nodes with category grouping

- Created src/layout/LayoutEngine.ts - a layout algorithm that:
  - Groups services by category (compute, storage, database, networking, security, etc.)
  - Arranges categories in a 4-column grid pattern with configurable spacing
  - Places services within each category in a grid to prevent overlaps
  - Configurable via LayoutConfig: nodeWidth, nodeHeight, nodePadding, categoryPadding, categoryColumns
  - Provides nodesOverlap() method for collision detection between two nodes
  - Provides validateNoOverlaps() method to verify entire layout has no collisions
  - Computes layout bounds (minX, maxX, minY, maxY) for view centering
- Updated src/main.ts to apply layout algorithm on initialization:
  - LayoutEngine.computeLayout() called before creating CanvasRenderer
  - Services receive new x/y coordinates that guarantee no overlaps
  - Original service data (name, description, keyPoints, etc.) preserved
- Added comprehensive tests in src/layout/LayoutEngine.test.ts:
  - Tests for constructor and custom configuration
  - Tests for computeLayout with empty, single, and multiple services
  - Tests for service property preservation
  - Tests for category grouping behavior
  - Tests for bounds calculation
  - Tests for nodesOverlap collision detection (overlapping, distant, touching edges)
  - Tests for validateNoOverlaps validation method
  - Tests for layout with 10+ services in same category
  - Tests for layout with services across 5 different categories
  - Tests for layout with real production services data (55 services)
  - Tests for layout consistency (deterministic results)
  - Tests for custom node dimensions
- All tests passing (104 tests: 7 data + 29 canvas + 37 info panel + 11 lambda + 20 layout)

## Add detailed descriptions for all services

- Expanded extendedDescription and resources from 7 services to all 57 services
- Added 2 new services to the catalog (expanded from 55 to 57 total)
- Each service now includes:
  - extendedDescription: comprehensive, certification-relevant technical details (150-300 words)
  - resources: 3 curated links (Documentation, Best Practices/Features, Pricing/Comparison)
- Content coverage includes:
  - Compute: EC2, Lambda, ECS, ECR, Fargate, Beanstalk, Auto Scaling, API Gateway, Step Functions, EKS
  - Storage: S3, EBS, EFS, Glacier, Storage Gateway, Snow Family
  - Database: RDS/Aurora, DynamoDB, ElastiCache, Redshift, Athena
  - Networking: VPC, Subnet, Internet Gateway, NAT Gateway, ELB, Direct Connect, VPN Gateway
  - Security: Security Groups, NACLs, IAM, KMS, Cognito, Secrets Manager, WAF, Shield, GuardDuty, Inspector
  - Management: CloudWatch, CloudTrail, Config, CloudFormation, Systems Manager, Trusted Advisor, Organizations, X-Ray
  - Messaging: SQS, SNS, EventBridge, Kinesis
  - CDN: CloudFront, Route 53
  - Cost: Cost Explorer, Budgets
  - DevTools: CodePipeline, CodeBuild, CodeDeploy
- Each extendedDescription covers:
  - Key concepts and terminology
  - Configuration options and modes
  - Integration patterns with other AWS services
  - Best practices and common use cases
  - Pricing model highlights
  - Certification exam relevance
- Gotchas discovered:
  - Resource links should use target="_blank" with rel="noopener noreferrer" for security (already implemented in InfoPanel.ts)
  - Extended descriptions should balance depth with readability - too long makes the UI feel cluttered
  - Consistent terminology across services helps users build mental connections
- All tests continue to pass (104 tests)

## Ensure smooth animations, especially when zooming in/out

- Enhanced src/canvas/CanvasRenderer.ts with animation system:
  - Added animation state properties: targetState, animationStartState, animationStartTime, animationDuration, animationFrameId
  - Implemented easeOutCubic() easing function for smooth deceleration (ease-out cubic: 1 - (1-t)^3)
  - Added animateTo() method to start smooth transitions to target state with configurable duration
  - Added animationLoop() using requestAnimationFrame for 60fps smooth interpolation
  - Added cancelAnimation() to interrupt animations (e.g., when user starts dragging)
  - Added public isAnimating() method to check animation state
- Applied smooth animations to zoom operations:
  - handleWheel() now animates zoom with 120ms duration for responsive wheel zoom
  - zoomAtCenter() (keyboard +/-) now animates with 150ms duration
  - centerViewOnContent() now animates with 400ms duration (optional animate=false parameter for initial load)
  - focusOnService() now animates with 400ms duration (optional animate=false parameter)
- User interactions properly interrupt animations:
  - handleMouseDown() cancels animation when drag starts
  - handleTouchStart() cancels animation when touch starts
  - Wheel events during animation accumulate zoom (reads from targetState if animating)
- Updated tests in src/canvas/CanvasRenderer.test.ts:
  - Added manual requestAnimationFrame mock (setupRAFMock) for reliable animation testing
  - Created flushAnimationFrames() helper to advance mock time and execute RAF callbacks
  - Created advanceMockTime() helper for partial animation testing
  - Added 7 new animation-specific tests:
    - Tests for isAnimating() state reporting
    - Tests for animation cancellation on drag
    - Tests for state interpolation during animation
    - Tests for ease-out easing behavior
    - Tests for zoom accumulation during animation
  - Updated existing tests to use animation helpers and animate=false parameter where appropriate
- Gotchas discovered:
  - Vitest's vi.useFakeTimers() doesn't reliably mock requestAnimationFrame in happy-dom environment
  - Manual RAF mocking with custom callback queue provides more predictable test behavior
  - performance.now() must also be mocked for animation timing to work correctly in tests
  - Wheel zoom needs to read from targetState (if animating) to accumulate rapid scroll events
  - Initial view setup should skip animation (animate=false) to avoid jarring load experience
- All tests pass (111 tests: 7 data + 36 canvas + 37 info panel + 11 lambda + 20 layout)

## Add a "toggle legends" button which toggles service categories visibility

- Added "Toggle Legend" button to the controls panel in index.html
- Added id="legend" to the legend element for JavaScript targeting
- Updated src/style.css with legend visibility transition:
  - Added transition properties (opacity, visibility, transform) to .legend
  - Created .legend.hidden class with slide-out animation (translateX(-20px))
  - Uses existing CSS variables (--transition-normal) for consistent timing
- Updated src/main.ts with toggle functionality:
  - Added references to toggleLegendBtn and legendElement
  - Created toggleLegend() function that uses classList.toggle('hidden')
  - Added event listener in setupControlListeners()
- Created comprehensive tests in src/ui/LegendToggle.test.ts:
  - Tests for default visible state (no hidden class)
  - Tests for toggle adding hidden class on first click
  - Tests for toggle removing hidden class on second click
  - Tests for multiple toggle cycles
  - Tests for preserving other classes during toggle
- Gotchas discovered:
  - The CSS visibility + opacity + transform pattern provides smooth hide/show animations
  - classList.toggle() is cleaner than manually checking and adding/removing classes
  - Testing DOM manipulation in Vitest with happy-dom is straightforward - just create elements and simulate clicks
  - The legend is already hidden on small screens (480px) via media query, so the toggle button provides desktop users with the same capability
- All tests pass (117 tests: 7 data + 36 canvas + 37 info panel + 11 lambda + 20 layout + 6 legend toggle)

## Add documentation in README

- Rewrote README.md from a sparse stub to comprehensive documentation
- Documentation includes:
  - Project overview and features summary
  - Getting started guide (prerequisites, installation, dev server)
  - Build and test commands
  - Project structure with file descriptions
  - Architecture overview explaining CanvasRenderer, LayoutEngine, and InfoPanel
  - Guide for adding new AWS services to the dataset
  - Service categories table with colors and example services
  - Keyboard shortcuts reference table
  - Link to DEPLOYMENT.md for deployment instructions
  - Tech stack summary
  - Complete npm scripts reference
- Gotchas discovered:
  - README should reference DEPLOYMENT.md rather than duplicate deployment content to avoid maintenance burden
  - The "Adding New Services" section is important for contributors - the x/y coordinates in JSON are ignored since LayoutEngine computes positions dynamically
  - Including keyboard shortcuts in README helps discoverability since they're not visible in the UI
  - Service count (57) and category count (10) should be verified against actual data before documenting
- All tests continue to pass (117 tests)

## Update layout/grid system to dynamic widths for service names

- Created src/utils/nodeWidths.ts utility module:
  - computeNodeWidth() function measures text using canvas ctx.measureText()
  - computeAllNodeWidths() computes widths for all services, creating temp canvas if needed
  - Configurable via NodeWidthConfig: font, minWidth (80px), maxWidth (200px), horizontalPadding (24px)
  - getDefaultNodeWidthConfig() returns a copy of the default configuration
- Updated src/canvas/CanvasRenderer.ts with dynamic width support:
  - Added nodeWidths property (Map<string, number>) to store computed widths
  - Constructor accepts optional nodeWidths parameter, falls back to computing them internally
  - Added private getNodeWidth(key) helper method with fallback to DEFAULT_NODE_WIDTH
  - Updated getServiceAtPosition() to use dynamic width for hit detection
  - Updated drawNode() to use dynamic width for rendering
  - Updated centerViewOnContent() to use dynamic widths for bounding box calculation
  - Added public getNodeWidths() getter to expose the widths map
  - NodeDimensions interface now only contains height and padding (width is per-node)
- Updated src/layout/LayoutEngine.ts to handle variable widths:
  - Changed LayoutConfig.nodeWidth to LayoutConfig.defaultNodeWidth for fallback
  - Constructor accepts optional NodeWidthMap as second parameter
  - Added setNodeWidths() public method to update widths after construction
  - Added private getNodeWidth(key) method with defaultNodeWidth fallback
  - Added private getMaxWidthForCategory() to compute max width within a category
  - Updated computeCategoryPositions() to use max width per category for grid sizing
  - Updated layoutCategoryServices() to use maxNodeWidth for consistent cell spacing
  - Updated nodesOverlap() signature to (key1, pos1, key2, pos2) for per-node widths
  - Updated validateNoOverlaps() to pass node keys for accurate collision detection
  - computeLayout() now uses per-node widths for bounds calculation
- Updated src/main.ts to integrate variable widths:
  - Imports computeAllNodeWidths from utils
  - Computes nodeWidths before creating LayoutEngine and CanvasRenderer
  - Passes same nodeWidths to both components for consistency
- Added comprehensive tests in src/utils/nodeWidths.test.ts (12 tests):
  - Tests for computeNodeWidth with various text lengths
  - Tests for minimum and maximum width constraints
  - Tests for custom configuration
  - Tests for computeAllNodeWidths producing correct Map
  - Tests for getDefaultNodeWidthConfig returning copies
- Updated src/layout/LayoutEngine.test.ts:
  - Changed nodeWidth references to defaultNodeWidth
  - Updated nodesOverlap() calls to use new 4-argument signature
  - Added 5 new tests for variable widths functionality
- Updated src/canvas/CanvasRenderer.test.ts:
  - Added measureText mock to createMockContext() returning text.length * 8
- Gotchas discovered:
  - Canvas measureText() requires an actual canvas context - JSDOM/happy-dom don't implement it
  - Test mock returns text.length * 8 as approximate character width for predictable testing
  - Category spacing uses max width of nodes in that category for uniform grid appearance
  - Node widths should be computed once and shared between LayoutEngine and CanvasRenderer
  - The nodesOverlap() method signature change is breaking - tests must be updated accordingly
  - Creating a temporary canvas for width computation works in browsers but needs context mock in tests
- All tests pass (134 tests: 7 data + 36 canvas + 37 info panel + 11 lambda + 25 layout + 6 legend toggle + 12 nodeWidths)

## Design: Add mesh gradient background and update color palette to teal/cyan

- Updated src/style.css with new teal/cyan color palette:
  - --color-primary: #14B8A6 (teal-500, previously purple #8B5CF6)
  - --color-primary-light: #2DD4BF (teal-400, previously #A78BFA)
  - --color-primary-dark: #0D9488 (teal-600, previously #6D28D9)
  - --color-bg-dark and --color-bg-darker adjusted to darker navy-teal tones
- Implemented mesh gradient background using layered radial gradients:
  - CSS doesn't natively support mesh gradients, so we simulate them with multiple radial-gradient layers
  - 5 radial gradients positioned at different coordinates (10%/20%, 85%/80%, 25%/60%, 75%/15%, 5%/95%)
  - Each uses elliptical shapes with varying sizes and opacity (0.12-0.25)
  - Colors include teal (#0D9488), cyan (#06B6D4), and a touch of blue (#3B82F6) for depth
  - Base layer is a linear gradient from dark navy (#0A1628) to dark teal (#081820)
- Updated all rgba(139, 92, 246, ...) references to rgba(20, 184, 166, ...):
  - Panel borders, scrollbar styling, close button backgrounds
  - Key points borders, extended content borders
  - Learn more button shadows
- Updated src/canvas/CanvasRenderer.ts connection line colors:
  - Connection stroke colors updated from purple to teal
  - Highlighted connection colors updated accordingly
- Gotchas discovered:
  - Mesh gradients are achieved by layering multiple radial-gradient() declarations in the background property
  - Each gradient should fade to transparent at its edges so they blend smoothly
  - Using ellipse shapes (rather than circles) creates more organic, flowing gradient shapes
  - Position gradients at different quadrants of the screen for balanced visual interest
  - Keep opacity low (0.1-0.25) to maintain a subtle, professional look without overwhelming the UI
  - The base linear gradient should be the last layer (rendered first/behind) to provide a consistent dark foundation
- All tests continue to pass (134 tests)

## Design: Use modern, smooth sans-serif fonts

- Added Inter font from Google Fonts to index.html:
  - Used preconnect hints for faster font loading
  - Loaded weights 400, 500, 600, 700 for body, medium, semibold, and bold text
  - Used display=swap for better loading performance
- Updated src/style.css with modern typography:
  - Added --font-family CSS variable for consistent font reference
  - Changed body font to Inter with system font fallbacks
  - Added -webkit-font-smoothing: antialiased for crisp rendering on WebKit browsers
  - Added -moz-osx-font-smoothing: grayscale for macOS Firefox
  - Added text-rendering: optimizeLegibility for better letter spacing and kerning
- Updated src/canvas/CanvasRenderer.ts:
  - Changed canvas text font to Inter with system font fallbacks
- Updated src/utils/nodeWidths.ts:
  - Changed default font configuration to Inter for consistent node width calculations
- Gotchas discovered:
  - Inter font is designed specifically for screens and has excellent readability at small sizes
  - The font stack should always include system font fallbacks for cases where web fonts fail to load
  - -webkit-font-smoothing: antialiased is essential for modern macOS rendering (without it, fonts appear too bold)
  - Canvas fonts don't automatically inherit from CSS, so they must be set explicitly with matching font stacks
  - Using preconnect hints for Google Fonts significantly improves load time by establishing early connections
  - display=swap ensures text is visible immediately with a fallback font while Inter loads
- All tests continue to pass (134 tests)

## Add Relationships section to InfoPanel

- Updated src/ui/InfoPanel.ts with relationships functionality:
  - Extended InfoPanelOptions interface with new optional properties:
    - onServiceSelect: callback when a related service is clicked
    - connections: array of [from, to] tuples representing service relationships
    - services: ServiceMap for looking up service details by key
  - Added getRelatedServices() private method that:
    - Scans connections for any involving the current service (bidirectional)
    - Returns [key, Service] tuples sorted alphabetically by service name
    - Filters out missing services from the services map
  - Updated render() to display "Related Services:" section with clickable buttons
  - Updated attachEventListeners() to handle clicks on related service buttons
  - Related service buttons use data-service-key attribute for identification
- Updated src/main.ts to pass connections and services to InfoPanel:
  - Reused existing handleServiceClick as onServiceSelect callback
  - This keeps the panel and canvas in sync when navigating via relationships
- Added comprehensive CSS styles in src/style.css:
  - .relationships section with border-top separator and header
  - .related-service-btn styled as pill buttons with hover/active states
  - Buttons use flexbox with wrap for responsive layout
  - Consistent with existing teal color palette and transition effects
  - Added focus-visible styles for keyboard accessibility
- Added 12 new tests in src/ui/InfoPanel.test.ts:
  - Tests for no relationships when no connections provided
  - Tests for no relationships when service has no connections
  - Tests for relationships section rendering with connections
  - Tests for correct button count and bidirectional relationship detection
  - Tests for alphabetical sorting of related services
  - Tests for data-service-key attribute on buttons
  - Tests for onServiceSelect callback invocation
  - Tests for graceful handling when callback not provided
  - Tests for XSS protection in related service names
  - Tests for filtering out missing services from the services map
- Gotchas discovered:
  - Connections are bidirectional: [a, b] means a→b AND b→a
  - Must check both 'from' and 'to' positions when finding related services
  - Related service buttons should use data attributes for service keys rather than relying on text content
  - When a service key exists in connections but not in services map, it should be silently filtered out
  - Sorting related services alphabetically provides consistent, predictable UI ordering
  - The onServiceSelect callback pattern allows the InfoPanel to remain decoupled from the canvas
- All tests pass (146 tests: 7 data + 36 canvas + 49 info panel + 11 lambda + 25 layout + 6 legend toggle + 12 nodeWidths)

## Ensure service positions are not hard-coded

- Updated src/types.ts with new type structure:
  - Made x and y optional in the base `Service` interface (for raw JSON data)
  - Created new `PositionedService` interface that extends Service with required x/y (for layout-computed data)
  - Created `PositionedServiceMap` type alias for Record<string, PositionedService>
  - This type separation enforces that positions are computed, not stored
- Removed all x/y coordinates from src/data/services.json:
  - 57 services × 2 coordinates = 114 coordinate values removed
  - JSON now contains only service content (name, category, description, etc.)
- Updated src/layout/LayoutEngine.ts:
  - Changed `LayoutResult.services` to return `PositionedServiceMap`
  - Updated `validateNoOverlaps()` to accept `PositionedServiceMap`
  - Removed unused `PositionedService` import
- Updated src/canvas/CanvasRenderer.ts:
  - Changed `services` property type to `PositionedServiceMap`
  - Changed constructor parameter to accept `PositionedServiceMap`
  - Updated `onServiceClick` callback to use `PositionedService`
  - Updated `drawNode` method signature to use `PositionedService`
  - Fixed type casts from `Service` to `PositionedService`
- Updated src/ui/InfoPanel.ts:
  - Changed `services` property type to `PositionedServiceMap`
  - Changed `currentService` type to `PositionedService`
  - Updated `show()` method parameter type
  - Updated `getRelatedServices()` return type
  - Updated `onServiceSelect` callback type
- Updated src/main.ts:
  - Changed imports to use `PositionedService` and `PositionedServiceMap`
  - Updated `layoutServices` variable type
  - Updated `handleServiceClick` function parameter type
- Updated test files:
  - src/data/services.test.ts: Removed x/y coordinate assertions (now computed dynamically)
  - src/canvas/CanvasRenderer.test.ts: Changed to use `PositionedServiceMap` type
  - src/layout/LayoutEngine.test.ts: Changed `validateNoOverlaps` tests to use `PositionedServiceMap`
  - src/ui/InfoPanel.test.ts: Changed to use `PositionedService` and `PositionedServiceMap` types
- Gotchas discovered:
  - Creating a separate `PositionedService` interface provides compile-time enforcement that x/y are computed
  - Using `extends Omit<Service, 'x' | 'y'>` pattern allows PositionedService to have required x/y while Service has optional
  - Raw service data (JSON) should use `ServiceMap`, while post-layout data uses `PositionedServiceMap`
  - The LayoutEngine's spread-with-override pattern `{ ...services[key], x: pos.x, y: pos.y }` correctly converts Service to PositionedService
  - Test data that includes x/y coordinates should be typed as `PositionedServiceMap` for type safety
  - The nodeWidths utility correctly uses `ServiceMap` since it operates on raw data before layout
- All tests pass (146 tests: 7 data + 36 canvas + 49 info panel + 11 lambda + 25 layout + 6 legend toggle + 12 nodeWidths)

## Enhanced panning animations with momentum and keyboard smoothing

- Added momentum/inertia effect to panning in src/canvas/CanvasRenderer.ts:
  - New velocity tracking properties: lastDragTime, velocityX, velocityY
  - Velocity calculated during drag using exponential smoothing (alpha=0.3) for noise reduction
  - New applyMomentum() method applies inertia on mouse/touch release
  - Momentum only triggers if speed exceeds threshold (0.15 px/ms) to avoid drift on slow drags
  - Momentum animation uses 600ms duration with ease-out cubic for natural deceleration
  - Momentum multiplier (180) determines how far the view "coasts" after release
- Added smooth animated keyboard panning:
  - New panByAmount() method animates panning with configurable duration
  - Arrow key panning now uses panByAmount() with 150ms duration instead of instant state changes
  - Accumulates direction if multiple keys pressed rapidly (reads from targetState if animating)
- Updated handleTouchEnd() to apply momentum on touch release, matching mouse behavior
- Reset velocity tracking on new drag start to prevent stale velocity from affecting new gestures
- Updated tests in src/canvas/CanvasRenderer.test.ts:
  - Added flushAnimationFrames() calls to keyboard navigation tests for animated panning
- Gotchas discovered:
  - Exponential smoothing (alpha blend between instant and previous velocity) reduces jitter from imprecise drag sampling
  - Momentum should only apply if user was actively dragging (wasDragging flag check)
  - Velocity must be reset when transitioning from pinch to single-finger drag to avoid momentum artifacts
  - The velocity threshold prevents tiny drifts when user releases mouse without meaningful movement
- All tests pass (146 tests)

## Ensure good performance

- Added viewport culling to src/canvas/CanvasRenderer.ts:
  - New VIEWPORT_PADDING constant (100px) for smooth edge rendering
  - New getViewportBounds() method calculates visible area in world coordinates
  - New isNodeInViewport() method checks if a node intersects the viewport
  - New isConnectionInViewport() method uses bounding box of line segment for quick rejection
  - drawNodes() now skips rendering nodes entirely outside the viewport
  - drawConnections() now skips rendering connections with both endpoints outside viewport
- Cached service entries for performance:
  - New serviceEntries property stores Object.entries(services) once at construction
  - Eliminates repeated array creation on every render, hit detection, and centerViewOnContent
  - getServiceAtPosition() now uses cached entries for hit detection
  - drawNodes() now uses cached entries for iteration
  - centerViewOnContent() now uses cached entries for bounding box calculation
- Built connection map for O(1) lookup:
  - New connectionMap property (Map<string, Set<string>>) stores bidirectional relationships
  - New buildConnectionMap() method constructs the map at construction time
  - Enables efficient connection highlighting when a service is selected
- Added comprehensive tests in src/canvas/CanvasRenderer.test.ts:
  - Tests for cached service entries working correctly across multiple renders
  - Tests for connection map building and usage during selection
  - Tests for viewport culling with nodes at extreme positions
  - Tests for viewport culling with connections far from viewport
  - Tests for empty services handling with cached entries
  - Tests for services at viewport boundaries
- Gotchas discovered:
  - Viewport padding should be scaled by the inverse of zoom level for consistent visual results
  - Bounding box check for line segments is a fast approximation - doesn't handle all diagonal cases perfectly but is sufficient for performance
  - Service entries must be cached at construction, not lazily, to ensure consistent behavior
  - Connection map is bidirectional (both directions stored) for O(1) lookup regardless of connection direction
  - The viewport bounds calculation must account for translation being in screen coordinates while positions are in world coordinates
- All tests pass (152 tests: 7 data + 42 canvas + 49 info panel + 11 lambda + 25 layout + 6 legend toggle + 12 nodeWidths)

## Add keyboard navigation between services

- Updated src/canvas/CanvasRenderer.ts with comprehensive keyboard service navigation:
  - Added sortedServiceKeys property to cache services sorted by category, then alphabetically by name
  - Added buildSortedServiceKeys() method to create the sorted list at construction time
  - Added navigateToNextService() method for Tab key navigation (cycles forward through services)
  - Added navigateToPreviousService() method for Shift+Tab navigation (cycles backward through services)
  - Added navigateToServiceInDirection() method for arrow key spatial navigation
  - Added getSortedServiceKeys() public method for testing
- Tab/Shift+Tab navigation:
  - Tab selects the next service in sorted order (by category, then alphabetically)
  - Shift+Tab selects the previous service in sorted order
  - Navigation wraps around (last service -> first, first service -> last)
  - If no service is selected, Tab selects first service, Shift+Tab selects last
- Arrow key spatial navigation:
  - When a service is selected, arrow keys navigate to the nearest service in that direction
  - Uses a weighted scoring algorithm: primaryDistance + perpendicularOffset * 0.5
  - 10px threshold prevents selecting services that are essentially in the same position
  - Falls back to panning if no service exists in the target direction
  - When no service is selected, arrow keys continue to pan as before
- Added 8 new tests in src/canvas/CanvasRenderer.test.ts:
  - Tests for Tab key selecting next service
  - Tests for Shift+Tab selecting previous service
  - Tests for cycling through all services with Tab
  - Tests for sorted service keys order (by category, then alphabetically)
  - Tests for spatial navigation with ArrowUp to service above
  - Tests for spatial navigation with ArrowRight to service on right
  - Tests for panning fallback when no service in direction
  - Tests for panning with arrow keys when no service is selected
- Gotchas discovered:
  - Service sorting should use localeCompare() for consistent cross-browser alphabetical ordering
  - The spatial navigation algorithm weights perpendicular offset at 0.5 to prefer services more directly in line
  - A 10px threshold in direction detection prevents edge cases where services at nearly the same position trigger navigation
  - The slice() call when sorting ensures the cached serviceEntries array is not mutated
  - focusOnService() both selects and centers the view, providing good UX when navigating with keyboard
  - Arrow key navigation should only trigger when a service is already selected, otherwise it conflicts with panning
- All tests pass (160 tests: 7 data + 50 canvas + 49 info panel + 11 lambda + 25 layout + 6 legend toggle + 12 nodeWidths)

## Add additional 'learn more' links for all services

- Expanded resources from 3 links per service to 5-6 links per service
- Added 114 new external educational resources across all 57 services:
  - AWS re:Invent talk links for deep-dive video content
  - Tutorials Dojo cheat sheets for exam preparation
  - freeCodeCamp tutorials for hands-on learning
  - Official AWS workshops for guided learning experiences
  - Community resources like The DynamoDB Book and EKS Workshop
- Resource distribution:
  - 41 services now have 5 resources
  - 16 services now have 6 resources
- Added 2 new tests in src/data/services.test.ts:
  - Test for resource count constraints (3-12 per service)
  - Test for valid resource structure (title and URL validation)
- Gotchas discovered:
  - Different types of resources serve different learning styles: videos for visual learners, cheat sheets for quick reference, workshops for hands-on practice
  - External tutorials often explain "why" better than official docs, which focus on "how"
  - Tutorials Dojo cheat sheets are particularly valuable for certification exam prep as they summarize key points
  - YouTube videos should link to specific talks rather than channel pages for better user experience
  - URLs should use https:// and point to stable documentation pages that are less likely to change
- All tests pass (162 tests: 9 data + 50 canvas + 49 info panel + 11 lambda + 25 layout + 6 legend toggle + 12 nodeWidths)

## Remove "learn more/show less" toggle functionality

- Updated src/ui/InfoPanel.ts to always show extended content:
  - Removed `isExpanded` state property (no longer needed)
  - Removed `isExtendedContentVisible()` public method
  - Removed `toggleExpanded()` public method
  - Removed `hasExtendedContent()` private method
  - Updated `render()` to always show extended content when service has extendedDescription or resources
  - Removed "Learn more"/"Show less" button from HTML output
  - Removed event listener for the toggle button in `attachEventListeners()`
  - Simplified `show()` and `hide()` methods (no more isExpanded state reset)
- Updated src/style.css:
  - Removed `.learn-more-btn` styles (display, hover, active states)
  - Removed `.learn-more-btn:focus-visible` from accessibility focus states
  - Kept `.extended-content` styles for the always-visible extended section
- Updated src/ui/InfoPanel.test.ts:
  - Renamed "Learn More functionality" describe block to "Extended content (always visible)"
  - Removed 10 tests related to toggle behavior (button visibility, click events, aria-expanded, state reset)
  - Updated remaining 8 tests to verify extended content is always shown when available
  - Updated XSS protection tests to remove `toggleExpanded()` calls (content now always visible)
- Gotchas discovered:
  - Removing state simplifies the component significantly - one less thing that can go wrong
  - The `hasExtendedContent()` helper was only used for button visibility, so it can be inlined
  - Test count decreased from 162 to 155 due to removed toggle-specific tests
  - The fadeIn animation on `.extended-content` still works well for initial panel appearance
  - Always showing extended content improves discoverability - users don't have to click to see resources
- All tests pass (155 tests: 9 data + 50 canvas + 42 info panel + 11 lambda + 25 layout + 6 legend toggle + 12 nodeWidths)

## Add additional animations - fade-in and connection transitions

- Enhanced src/canvas/CanvasRenderer.ts with two new animation systems:
  - **Initial fade-in animation**: Network diagram fades in smoothly over 800ms upon page load
  - **Connection opacity transitions**: Connections animate opacity when selecting/deselecting services
- Added animation configuration constants at module level:
  - FADE_IN_DURATION: 800ms for initial canvas fade-in
  - CONNECTION_TRANSITION_DURATION: 300ms for connection opacity changes
  - CONNECTION_OPACITY_NORMAL: 0.3 (default connection opacity)
  - CONNECTION_OPACITY_HIGHLIGHTED: 0.8 (opacity for selected service connections)
  - CONNECTION_OPACITY_DIMMED: 0.1 (opacity for unrelated connections when a service is selected)
- Added new properties to CanvasRenderer:
  - globalOpacity: Tracks overall canvas opacity for fade-in effect (0 → 1)
  - fadeInStartTime, fadeInAnimationId: Track fade-in animation state
  - connectionOpacities: Map<string, number> storing current opacity per connection
  - connectionTargetOpacities: Map<string, number> storing target opacity per connection
  - connectionAnimationStartTime, connectionAnimationId: Track connection animation state
- Implemented new private methods:
  - initializeConnectionOpacities(): Sets all connections to normal opacity at construction
  - getConnectionKey(from, to): Creates order-independent key for connection lookup
  - startFadeInAnimation(): Initiates the global opacity animation
  - fadeInLoop(): requestAnimationFrame loop for fade-in interpolation
  - updateConnectionTargets(selectedKey): Calculates target opacities based on selection
  - startConnectionAnimation(): Begins connection opacity transition
  - connectionAnimationLoop(): requestAnimationFrame loop for connection interpolation
  - getConnectionOpacity(from, to): Returns current animated opacity for a connection
- Updated drawNode() to apply globalOpacity using ctx.globalAlpha:
  - Sets globalAlpha before drawing, resets to 1 after
  - Shadow opacity also scales with globalOpacity
- Updated drawConnections() to use animated opacities:
  - Combines connection opacity with globalOpacity for final stroke color
  - Uses rgba() with computed opacity instead of hardcoded values
- Updated selectService() to trigger connection animations when selection changes
- Updated handleClick() to trigger connection animations on mouse click
- Updated handleTouchEnd() to trigger connection animations on touch
- Updated handleKeyDown() for Escape key to trigger connection animation
- Updated focusOnService() to trigger connection animation
- Added 6 new tests in src/canvas/CanvasRenderer.test.ts:
  - Tests for fade-in animation starting on construction
  - Tests for connection opacity animation on service selection
  - Tests for dimming unrelated connections
  - Tests for restoring opacities when selection is cleared
  - Tests for connection animation on keyboard navigation
  - Tests for connection animation on Escape key press
- Gotchas discovered:
  - When testing globalAlpha, you can't just check its final value since drawNode resets it to 1 - need to spy on the setter
  - Connection keys should be order-independent (a:b == b:a) to avoid duplicate state
  - The connection animation uses lerp (linear interpolation) within the easing - each frame moves toward target rather than replaying from start
  - Multiple animation systems can run concurrently (fade-in + connection + view panning) without interference
  - Initializing connection opacities in constructor ensures first render has correct values before any animations
  - The globalAlpha approach is cleaner than manually adjusting each color's alpha channel
- All tests pass (161 tests: 9 data + 56 canvas + 42 info panel + 11 lambda + 25 layout + 6 legend toggle + 12 nodeWidths)

## Centralize configuration - remove magic numbers and hardcoded values

- Created src/config/index.ts as the central configuration file containing:
  - COLORS: Primary color palette (teal/cyan), RGB values, text and border colors, shadow color, fallback category colors
  - CATEGORY_COLORS: All 10 category gradient colors (compute, storage, database, networking, security, management, cost, messaging, cdn, devtools)
  - TYPOGRAPHY: Font family, weight, size, and computed canvas font string
  - NODE_DIMENSIONS: Default width, height, padding, border radius
  - NODE_WIDTH_CONFIG: Min/max width constraints, horizontal padding for text measurement
  - ANIMATION: All timing values (fade-in, connection transition, zoom, pan, momentum, view transition durations)
  - CONNECTION_OPACITY: Normal, highlighted, and dimmed opacity values
  - CONNECTION_LINE_WIDTH: Normal and highlighted line widths
  - NODE_SHADOW: Blur and offset values for normal and active states
  - NODE_BORDER: Border widths for selected and hovered states
  - ZOOM: Min/max limits, wheel factors, keyboard step, focus scale, max fit content
  - INTERACTION: Drag threshold, pan step, view padding, viewport culling padding, spatial navigation threshold and weight
  - MOMENTUM: Velocity threshold, multiplier, smoothing factor
  - LAYOUT: Node dimensions and spacing for layout engine
  - BREAKPOINTS: Tablet (768px) and mobile (480px) breakpoints
- Updated src/canvas/CanvasRenderer.ts to import from config:
  - Replaced 30+ magic numbers with config constants
  - Removed local constant definitions (CATEGORY_COLORS, NODE_DIMENSIONS, etc.)
  - Uses COLORS.primaryRGB for connection stroke color
  - Uses TYPOGRAPHY.canvasFont for node text rendering
  - Uses ZOOM.* for all scale limits and factors
  - Uses ANIMATION.* for all duration values
  - Uses INTERACTION.* for drag threshold, pan step, spatial navigation
  - Uses MOMENTUM.* for velocity tracking and inertia
  - Uses CONNECTION_OPACITY.* and CONNECTION_LINE_WIDTH.* for connection rendering
  - Uses NODE_SHADOW.* and NODE_BORDER.* for node appearance
- Updated src/layout/LayoutEngine.ts to import LAYOUT config:
  - DEFAULT_CONFIG now derives values from LAYOUT constants
- Updated src/utils/nodeWidths.ts to import from config:
  - Uses TYPOGRAPHY.canvasFont for font measurement
  - Uses NODE_WIDTH_CONFIG for width constraints
- Updated src/style.css with CSS custom properties:
  - Added --color-primary-rgb: 20, 184, 166 for use in rgba()
  - Added opacity variants: --color-primary-10 through --color-primary-60
  - Replaced 20+ instances of `rgba(20, 184, 166, ...)` with CSS variables
  - Added commented breakpoint variables for documentation
- Added comprehensive tests in src/config/index.test.ts (29 tests):
  - Tests for valid color formats and values
  - Tests for all 10 category colors with hex pattern validation
  - Tests for typography configuration
  - Tests for dimension constraints (min < max, positive values)
  - Tests for opacity values in valid 0-1 range
  - Tests for hierarchical relationships (highlighted > normal > dimmed)
  - Tests for zoom constraints (min < max, valid factors)
  - Tests for interaction thresholds being positive
  - Tests for momentum smoothing factor in valid range
  - Tests for layout values and integer constraints
  - Tests for breakpoint ordering (tablet > mobile)
- Gotchas discovered:
  - CSS custom properties with rgb values allow variable opacity via `rgba(var(--color-primary-rgb), 0.5)`
  - TypeScript `as const` assertions on config objects provide better type inference and prevent accidental mutation
  - The getter pattern for `canvasFont` ensures the font string is always derived from other config values
  - Config values that reference other config values (like LAYOUT using NODE_DIMENSIONS) should use the same source of truth
  - Some constants like shadow color need dynamic opacity calculation at runtime, so storing the base color separately from opacity is useful
  - CSS variables cascade, so components can override the root variables for theming if needed
  - When replacing magic numbers, ensure tests still work - some tests may have hardcoded expected values that need updating
  - Using descriptive constant names makes code more self-documenting (e.g., `ZOOM.maxFitContent` vs `1.5`)
- All tests pass (190 tests: 9 data + 56 canvas + 42 info panel + 11 lambda + 25 layout + 6 legend toggle + 12 nodeWidths + 29 config)

## Revise services list - add missing certification-relevant services

- Added 10 new AWS services frequently tested in Cloud Practitioner, Solutions Architect Associate, and Developer Associate certifications:
  - **Aurora**: Cloud-native relational database with MySQL/PostgreSQL compatibility (database)
  - **Macie**: Data security service that discovers and protects sensitive data in S3 (security)
  - **Artifact**: On-demand access to AWS compliance reports and agreements (management)
  - **FSx**: Fully managed file systems - Windows File Server, Lustre, NetApp ONTAP, OpenZFS (storage)
  - **Global Accelerator**: Network service that improves global application performance (cdn)
  - **Transit Gateway**: Network hub for connecting VPCs and on-premises networks (networking)
  - **DMS**: Database Migration Service for migrating databases to AWS (database)
  - **Glue**: Serverless data integration and ETL service with Data Catalog (database)
  - **AppSync**: Managed GraphQL API service with real-time subscriptions (compute)
  - **Lightsail**: Simple virtual private servers with predictable pricing (compute)
- Expanded total service count from 57 to 67 services
- Added 29 new connections for the new services in connections.json:
  - Aurora connects to: rds, secretsmanager, subnet, securitygroup
  - Macie connects to: s3, eventbridge, kms
  - Artifact connects to: organizations
  - FSx connects to: s3, vpc
  - Global Accelerator connects to: elb, ec2, shield
  - Transit Gateway connects to: vpc, vpngateway, directconnect
  - DMS connects to: rds, aurora, dynamodb, s3, snowfamily
  - Glue connects to: s3, athena, redshift, dynamodb
  - AppSync connects to: dynamodb, lambda, cognito, rds
  - Lightsail connects to: vpc
- Total connections expanded from 106 to 135
- Each new service includes:
  - Comprehensive description and details
  - 5-6 certification-relevant key points
  - Extended description covering architecture, use cases, and exam topics
  - 5 curated resources (documentation, pricing, video tutorials, cheat sheets)
- Gotchas discovered:
  - Aurora is often tested separately from RDS in certification exams - it has its own distinct features like Serverless v2, Global Database, and Backtrack
  - Transit Gateway solves the N×(N-1)/2 VPC peering problem - a common Solutions Architect exam topic
  - DMS supports both homogeneous and heterogeneous migrations - Schema Conversion Tool (SCT) is needed for heterogeneous
  - Glue Data Catalog is the central metadata repository that Athena, Redshift Spectrum, and EMR query directly
  - Global Accelerator vs CloudFront is a common exam comparison: GA optimizes network path, CloudFront caches content
  - Macie is specifically for S3 sensitive data discovery, while GuardDuty is for threat detection across multiple services
  - FSx for Lustre integrates with S3 and is commonly used for HPC and ML training workloads
  - Lightsail is the "beginner-friendly" EC2 alternative with bundled pricing - important for Cloud Practitioner
- All tests pass (190 tests, unchanged as data tests validate structure dynamically)

## Add title headings for different sections, remove service categories legend

- Category headings were already implemented in src/canvas/CanvasRenderer.ts:
  - `drawCategoryHeadings()` method renders category names above each group
  - Uses `CategoryPosition` interface from types.ts for positioning data
  - Integrates with `TYPOGRAPHY.categoryHeading` config for font, size, opacity, and offset
  - Applies viewport culling for performance (skips headings outside view)
  - Respects globalOpacity for fade-in animation consistency
- LayoutEngine returns category positions via `LayoutResult.categories`:
  - Each category includes displayName, x, y, width, and height
  - Human-readable display names defined in `CATEGORY_DISPLAY_NAMES` mapping
- Service categories legend was already removed:
  - No legend element exists in index.html
  - No LegendToggle.ts file or related tests
  - Legend toggle button was removed from controls panel
- Test coverage already existed in CanvasRenderer.test.ts:
  - `should accept category positions and draw category headings` (line 1054)
  - `should render without category positions` (line 1085)
- Updated src/style.css comment:
  - Changed `/* Category colors for legend */` to `/* Category colors for info panel badges */`
  - Category color classes (.compute, .storage, etc.) are used by InfoPanel category badges
- Gotchas discovered:
  - The category headings feature was implemented as part of an earlier commit but not marked as complete in PRD
  - The legend removal appears to have been done incrementally - test file deleted, code removed, but PRD task remained open
  - Always verify test coverage exists before marking canvas-related features complete
  - The heading colors use the lighter gradient color (colors.start) for better visibility on dark backgrounds
- All tests pass (191 tests: 9 data + 58 canvas + 42 info panel + 11 lambda + 30 layout + 12 nodeWidths + 29 config)

## Remove title box with buttons - replace with simple title

- Updated index.html:
  - Replaced `.controls` div containing h3 + 2 buttons with `.title-panel` div containing simple h1 "AWS Services"
  - Removed Reset View and Focus Security/Network buttons
- Updated src/main.ts:
  - Removed DOM references to resetBtn and focusBtn elements
  - Removed resetView() function
  - Removed focusNetworking() function
  - Removed setupControlListeners() function and its call in init()
- Updated src/style.css:
  - Renamed `.controls` to `.title-panel` in shared panel styles
  - Simplified panel from full controls section to minimal title styling
  - Removed all button styles (.controls button, :hover, :active, :last-child, :focus-visible)
  - Updated responsive styles for .title-panel at 768px and 480px breakpoints
  - Removed hover shadow effect (no longer needed for non-interactive panel)
- Fixed pre-existing TypeScript build errors:
  - `connectionMap` property was declared but never read - added public getConnectionMap() getter
  - `fadeInAnimationId` property was declared but never read - added public isFadeInAnimating() method
  - Changed `_connectionMap` and `_fadeInAnimationId` to remove underscore prefix for consistency
- Gotchas discovered:
  - TypeScript's `noUnusedLocals: true` flag catches class properties that are assigned but never read
  - The underscore prefix convention (`_property`) doesn't suppress "unused" warnings for class properties in TypeScript
  - Properties built for "future use" or "O(1) lookup" must either be used or exposed via getters to pass strict compilation
  - When removing UI elements, remember to also remove the JavaScript event listeners and DOM references
  - The PRD mentioned "3 buttons" but only 2 existed (Reset View, Focus Security/Network) - the Toggle Legend button was removed earlier
- All tests pass (191 tests: 9 data + 58 canvas + 42 info panel + 11 lambda + 30 layout + 12 nodeWidths + 29 config)

## Add staggered zoom-in animation for service nodes

- Added new animation configuration constants to src/config/index.ts:
  - `nodeZoomInDuration`: 500ms per-node animation duration
  - `nodeZoomInStaggerDelay`: 25ms delay between each node's animation start
  - `nodeZoomInStartScale`: 0.3 (nodes start at 30% scale)
- Updated src/canvas/CanvasRenderer.ts with staggered zoom-in animation system:
  - Added `nodeScales` Map to track per-node scale during animation
  - Added `nodeAnimationStartTimes` Map to store staggered start times
  - Added `nodeAnimationId` to track active animation frame
  - Added `initializeNodeScales()` method that:
    - Sorts services by category and position for wave-like visual effect
    - Initializes each node at start scale with staggered animation timing
  - Added `startNodeZoomInAnimation()` to begin the animation loop
  - Added `nodeZoomInLoop()` animation loop that:
    - Calculates per-node progress based on staggered start times
    - Uses easeOutCubic for smooth deceleration
    - Interpolates scale from startScale to 1
    - Continues until all nodes reach full scale
  - Added `getNodeScale()` helper to retrieve current node scale
  - Added public `isNodeZoomInAnimating()` method for testing
  - Added public `getNodeScaleForKey()` method for testing
- Modified `drawNode()` to use per-node scale:
  - Scales node width, height, and border radius from center
  - Scales shadow blur and offset proportionally
  - Scales font size for smooth text zoom effect
  - Combines globalOpacity with nodeScale for text fade-in effect
- Added 6 new tests in src/canvas/CanvasRenderer.test.ts:
  - Test for animation starting on construction
  - Test for nodes starting at reduced scale
  - Test for all nodes reaching full scale after animation
  - Test for staggered animation timing (later nodes start later)
  - Test for text scaling along with nodes
  - Test for combined opacity/scale fade-in effect
- Added 2 new tests in src/config/index.test.ts:
  - Test for positive node zoom-in durations
  - Test for valid start scale (between 0 and 1)
- Gotchas discovered:
  - Nodes sorted by category then position creates visually pleasing "wave" effect
  - Using nodeScale for both size AND opacity gives a "pop-in" effect (nodes appear to zoom in from small/transparent)
  - Font size must be scaled separately since canvas font is a string property, not affected by ctx.scale()
  - Shadow blur/offset should scale with node to maintain visual proportions during animation
  - The stagger delay (25ms) multiplied by number of services gives total stagger time - with 67 services, last node starts ~1.7s after first
  - Scaling from center is achieved by using scaled halfWidth/halfHeight in position calculations
  - The animation runs concurrently with the global fade-in, creating a layered effect
- All tests pass (198 tests: 9 data + 64 canvas + 42 info panel + 11 lambda + 30 layout + 12 nodeWidths + 30 config)
